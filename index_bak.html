<script id="defaultVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPos;

        void main() {
            vUv = uv;
            vPos = (modelMatrix * vec4(position, 1.0 )).xyz;
            vNormal = (modelMatrix * vec4(normal, 0.0)).xyz;

            gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(position,1.0);
        }
</script>

<script id="defaultFragmentShader" type="x-shader/x-fragment">

        uniform sampler2D texture;
        uniform sampler2D texture2;
        uniform float time;
        varying vec3 vNormal;
        varying vec2 vUv;

        varying vec3 vPos;
        uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
        uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
        uniform float pointLightDistance[MAX_POINT_LIGHTS];

        void main() {

                // Spawn the lights that will be used later in calcs
                vec3 lightDirection;
                vec4 addedLights = vec4(0.0,0.0,0.0, 1.0);
                for(int l = 0; l < MAX_POINT_LIGHTS; l++) {
                    lightDirection = normalize(vPos
                                          -pointLightPosition[l]);
                    addedLights.rgb += clamp(dot(-lightDirection,
                                             vNormal), 0.0, 1.0)
                                       * pointLightColor[l];

                }

                // Construct the lights
                vec4 lights = clamp(addedLights,0.1,1.0);

                // Set up our base-layer w/ light
                vec3 dayComponent = texture2D( texture, vUv ).rgb;
                vec4 dayColors = vec4( dayComponent, 1.0 ) * lights;

                // Set up the night lights
                vec3 nightComponent = texture2D( texture2, vUv ).rgb;
                vec4 nightColors = vec4(nightComponent,1.0) * (1.0 - lights);

                // Add the results;
                gl_FragColor = dayColors + nightColors;

        }
</script>

<script>
    // Initialize WebGL Renderer
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    var canvas = document.getElementById('canvas').appendChild(renderer.domElement);

    // Initialize Scenes
    var scene = new THREE.Scene();

    // Initialize Camera
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 200;

    // Create Ball
    var vertShader = document.getElementById('defaultVertexShader').innerHTML;
    var fragShader = document.getElementById('defaultFragmentShader').innerHTML;
    var tex2 = THREE.ImageUtils.loadTexture( "/nightlights.jpg" );
    var tex = THREE.ImageUtils.loadTexture( "/mainmap.jpg" );

    var uniforms = THREE.UniformsUtils.merge([
    THREE.UniformsLib["lights"],
    {
        texture: { type: 't', value: tex },
        texture2: { type: 't', value: tex2 },
        time: { type: 'f', value: 1.0 },
    }]);

    var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertShader,
        fragmentShader: fragShader,
        lights: true,
    });

    // Problem area?
    material.uniforms.texture.value.needsUpdate = true;
    material.uniforms.texture2.value.needsUpdate = true;
    material.uniforms.time.value.needsUpdate = true;
    //



    var ball = new THREE.Mesh(new THREE.SphereGeometry(30, 30, 30), material)
    scene.add(ball);
    ball.position.set(-150,0,0);
    ball.rotation.y +=0.5;

    // Create Light
    var light = new THREE.PointLight(0xFFFFFF,3,1000);
    light.position.set(0, 0, 0);
    scene.add(light);

    var controls = new THREE.TrackballControls(camera);
    scene.add(controls);
    // Render the Scene
    renderer.render(scene, camera);


    render = function() {
        requestAnimationFrame(render);
        material.uniforms.time.value += 0.1;
        ball.rotation.y += 0.005;
        controls.update();
        renderer.render(scene, camera);
    }
    render();

</script>
